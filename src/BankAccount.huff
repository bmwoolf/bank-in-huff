/* Interface */
#define function deposit(uint256) payable returns ()
#define function wire(address,uint256) payable returns (bool)
#define function withdraw(uint256) payable returns (uint256)
#define function getBalance() view returns (uint256)

/* Storage Layout */
#define constant MASK_ADDR = 0xffffffffffffffffffffffffffffffffffffffff

/* Storage Slots */
#define constant USD_ADDRESS = FREE_STORAGE_POINTER() // access these from sloads
#define constant OWNER_ADDRESS = FREE_STORAGE_POINTER()
#define constant ADDRESSES = FREE_STORAGE_POINTER()

/* Events */
#define event Deposit(address,uint256)
#define event Wire(address,address,uint256)
#define event Withdraw(address,uint256)

/* Event Signatures */
#define constant DEPOSIT_SIG = 0x47e7ef24b3022e382e65b1298581281f0ae273ac4f76464efcf5b06769264f2f
#define constant WIRE_SIG = 0xdbb338c7606de3f52f73ed8c0062346e93bacb183eb366c630d2a72af9ee96d3
#define constant WITHDRAW_SIG = 0xf3fef3a3f44f9c277339b67d54f015748bd8d6b77a985b0ab6e71126b018c34a

/* Methods */
#define macro CONSTRUCTOR() = takes(0) returns (0) {
    // Set msg.sender as the owner of the contract.
    caller [OWNER_ADDRESS] sstore
}

#define macro DEPOSIT(amount) = takes(1) returns(0) {
    0x04 calldataload   // [value]
}

#define macro WITHDRAW(amount) = takes(1) returns(0) {
    // require that it is the owner of the account
    ONLY_OWNER()
    // call opcode transferring from contract to individual
}

// pass in the contract address of the receiver bank account
#define macro WIRE(to) = takes(1) returns(0) {
    ONLY_OWNER()
    // need to access msg.value
    <to> mstore  // smart contract representing the receiver's bank account

    push1 0x00 //retSize
    push1 0x00 //retOffset
    push1 0x20 //argsSize
    push1 0x00 //argsOffset
    // push1 0x00 //value
    callvalue // pushes value onto the stack
    push20 <to> //dup7 //address
    push2 0xFFFF // gas- 65,535 units
    call

    // emit wire event
    caller
    0x20 // to- would this be 0x00?
    [WIRE_SIG]
    log2
}

#define macro GET_BALANCE() = takes(0) returns(0) {
    NO_VALUE_CHECK(returndatasize)
    // how do i return the ether value?
}


/* Utils */
#define macro NO_VALUE_CHECK(zero) = takes(0) returns (0) {
    callvalue iszero valueCheck jumpi
        <zero> <zero> revert
    valueCheck:
}


/* Modifiers */
#define macro ONLY_OWNER() = takes(0) returns(0) {
    [OWNER_ADDRESS] sload caller eq is_owner jumpi
        <zero> <zero> revert
    is_owner: // returns out and continues the function execution
}

/* Main jump table for the contract */
#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called.
    // <zero> calldataload 0xE0 shr // causing errors "Unmatched Jump Table"
    dup1 0x55241077 eq deposit jumpi
    dup1 0xc32cefa1 eq wire jumpi
    dup1 0x2e1a7d4d eq withdraw jumpi
    dup1 0x12065fe0 eq getBalance jumpi

    deposit:
        DEPOSIT()
    wire:
        WIRE()
    withdraw:
        WITHDRAW()
    getBalance:
        GET_BALANCE()
}